# Конструирование программного обеспечения
## Домашнее задание №2
## Андраш Тот

### Задание
Разработать систему управления заказами в ресторане, которая поддерживает два типа пользователей: посетителей и администраторов. Система должна обрабатывать заказы в многопоточном режиме, позволяя клиентам добавлять блюда в заказ в реальном времени, а также отображать статусы заказов. Администраторы могут управлять меню, добавляя или удаляя блюда. Все решения должны соблюдать принципы ООП и SOLID, а также использовать шаблоны проектирования, где это уместно.


_Требования_:
- Реализуйте систему аутентификации для двух типов пользователей: посетителей и администраторов.
- Администратор может добавлять и удалять блюда из меню, а также устанавливать их количество, цену и сложность выполнения (время, которое оно будет готовиться).
- Посетители могут составлять заказ, выбирая блюда из актуального меню.
- Заказы обрабатываются в отдельных потоках, симулируя процесс приготовления.
- Посетители могут добавлять блюда в существующий заказ, пока он находится в обработке.
- Посетители должны иметь возможность отменять заказ до того, как он будет готов.
- Система должна отображать актуальный статус заказа (например, "принят", "готовится", "готов").
- По завершении выполнения заказа посетитель должен иметь возможность его оплатить.
- Необходимо сохранять состояния программы: меню, сумму выручки, пользователей в системе, а также то, что вы посчитаете нужным.


_Критерии оценки_
- Применение принципов ООП и SOLID (0 – 1 балл)
- Аутентификация (0 – 1 балл)
- Использование шаблонов проектирования (0 – 1 балл)
- Хранение данных (0 – 1 балл)
- Реализация многопоточности для обработки заказов (0 – 2 балла)
- Codestyle (0 – 1 балл)
- readme с описанием того, как пользоваться программой, какие шаблоны были использованы в проекте и почему (0 – 0.5 балла)
- Понятный интерфейс (0 – 0.5 балла)


_Опциональное задание (на дополнительные 1 – 2 балла)_
- Дать возможность клиентам оставлять отзывы о блюдах после оплаты заказа. Отзывы должны включать оценку от 1 до 5 и текстовый комментарий.
- Реализовать функционал, позволяющий администратору просматривать статистику по заказам и отзывам (например, самые популярные блюда, средняя оценка блюд, количество заказов за период).
- Система приоритетов для обработки заказов (вы должны сами решить, по какому принципу приоритезированы заказы, объяснив своё решение в readme). 

_Дополнительно_
- Штраф –3 балла за наличие ошибки во время выполнения кода
- Оценка снижается до 0, если программа не собирается (должен быть предоставлен полный код программы)
- Код должен быть загружен на удаленный Git-репозиторий с четкой структурой каталогов и созданным pull/merge request из ветки develop в пустую ветку main.
- Предусмотрено снижение оценки пропорционально объему невыполненных функциональных требований.


Выполнять ДЗ можно на языках Kotlin или Java.

### Описание решения
#### Руководство пользователя
Перед использованием программы рекомендуется сделать высоту окна консоли как можно большей. Для использования программы необходимо следовать интсрукциям на экране. В любой части программы Вы можете отменить текущую процедуру (вернуться назад),
введя команду `/back` или выбрав её среди доступных.

#### Описание архитектуры
В исходном коде приложение представлено классом Application. У приложения могут быть разные состояния (например, _начальное_, _состояние работы с меню_ и т.п.). Состояния приложения представлены классами-наследниками класса ApplicationState. 
В каждом состоянии пользователю доступны определенные команды (например, _выполнить вход в учётную запись_, _создать заказ_ и т.п.). Команды представлены классами, реализующими интерфейс Command<T>. Команда может выполнять какое-то действие,
требуемое пользователем, или переводить приложение в другое состояние. Авторизация реализована посредсвом хранения приложением объекта класса Session, хранящего необходимую логику. Ниже приведено краткое описание пакетов верхнего уровня
директории с исходным кодом:

- kotlin/commands - в данном пакете хранятся команды и их общий интерфейс Command<T>
- kotlin/crud - в данном пакете хранятся классы и интерфейсы, ответственные за сохранение данных приложения
- kotlin/entities - в данном пакете хранятся бизнес-объекты
- kotlin/factories - в данном пакете хранятся фабрики объектов из других пакетов и необходимые для фабрик интерфейсы
- kotlin/observation - в данном пакете содержится класс Event<T>, являющийся упрощенной реализацией события C#. Во время разработки было принято решение вместо паттерна наблюдатель использовать событие, так как паттерн наблюдатель не поддерживает
наблюдение сразу за несколькими объектами
- kotlin/states - в данном пакете хранятся состояния приложения и их общий класс-предок ApplicationState
- kotlin/utils - в данном пакете хранятся классы, реализующие функционал, используемый классами из других пакетов


Использованные паттерны:

- Паттерн состояние (класс ApplicationState и производные). Обоснование: паттерн буквально позволяет объекту поддерживать разные состояния (которые могут знать о сущестовании друг друга), в зависимости от которых может меняться его поведение.
Именно это и требовалось при создании приложения
- Паттерн Команда (интерфейс Command<T> и классы, его реализующие). Обоснование: во время разработки необходимо было каким-то образом инкапсулировать в объекты различное поведение, но при этом снабдить их все общим интерфейсом, чтобы их можно
было передавать и вызывать, не завися от конкретного типа. Паттерн команда позволяет получить необходимое поведение.
- Паттерн Фабрика (от источника к источнику ее то включают, то не включают в паттерны, но у нас в курсе она была упомянута среди порождающих паттернов) (интерфейс CommandFactory<T> и классы, его реализующие). Обоснование: в зависимости от разных
условий в конкретный момент времени пользователю внутри одного состояния приложения может быть доступен разный набор команд. Паттерн фабрика позволяет обеспечить удобный механизм генерации конкретного набора команд.
- Паттерн Стратегия (интерфейс OrderPresentationStrategy и классы, его реализующие, интерфейс MenuItemPresentationStrategy и классы, его реализующие). Обоснование: в зависимости от разных условий отображение на экран одной и той же сущности может
меняться, используя разные алгоритмы. Паттерн стратегия позволяет легко менять конкретные алгоритмы.
- Паттерн Абстрактная фабрика (интерфейс ApplicationMemberFactory и классы, его реализующие, а также класс Application). Обоснование: в ходе развития проекта может возникнуть необходимость задать другие значения членам класса Application,
представляющим набор абстрактных ссылок. Кроме того, возможны разные конфигурации значений полей. Паттерн Абстрактная фабрика позволяет легко поддерживать создание различных наборов большого числа объектов (конфигураций). 

